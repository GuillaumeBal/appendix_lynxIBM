range360 = TRUE))
}
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_true(all(nextCellsTypeDir[, "dir"] %in% c(0, 45, 90, 135, 180, 225, 270, 315)))
expect_equivalent(length(yesCorr), length(unique(nextCellsTypeDir$id)))
}
# Rank the direction as preferences
nextCellsTypeDir <- cbind(nextCellsTypeDir, prefDir = 1)
nextCellsTypeDir[nextCellsTypeDir[, "dir"] %in% c(45, 315), "prefDir"] <- 2
nextCellsTypeDir[nextCellsTypeDir[, "dir"] %in% c(90, 270), "prefDir"] <- 3
nextCellsTypeDir[nextCellsTypeDir[, "dir"] %in% c(135, 225), "prefDir"] <- 4
nextCellsTypeDir[nextCellsTypeDir[, "dir"] == 180, "prefDir"] <- 5
nextCellsTypeDir[nextCellsTypeDir[, "pxcor"] == nextCellsTypeDir[, "pxcorHere"]
& nextCellsTypeDir[, "pycor"] == nextCellsTypeDir[, "pycorHere"],
"prefDir"] <- 3
nextCellsTypeDirDT <- as.data.table(nextCellsTypeDir)
chosenCellsYesCorrDT <- nextCellsTypeDirDT[nextCellsTypeDirDT[, .I[sample(.N,1)],
by = c("id","prefDir")]$V1]
# Select the cell with the smallest rotation
#chosenCellsYesCorrSelect <- as.matrix(chosenCellsYesCorrDT[, .SD[which.min(prefDir)], by = id]) # the two lines after are faster than these two lines
#chosenCellsYesCorrSelect <- chosenCellsYesCorrSelect[, c("pxcor", "pycor", "id", "cellType")]
chosenCellsYesCorrSelectDT <- chosenCellsYesCorrDT[, .SD[which.min(prefDir)], by = id]
chosenCellsYesCorrSelect <- cbind(pxcor = chosenCellsYesCorrSelectDT$pxcor, pycor = chosenCellsYesCorrSelectDT$pycor,
id = chosenCellsYesCorrSelectDT$id, cellType = chosenCellsYesCorrSelectDT$cellType)
}
# Regroup the individuals that had not a correlation movement and the ones that had
chosenCells <- rbind(chosenCellsNoCorr, chosenCellsYesCorrSelect)
chosenCells <- chosenCells[order(chosenCells[, "id"]), , drop = FALSE]
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_equivalent(NROW(chosenCells), length(unique(chosenCells[, "id"])))
expect_equivalent(NROW(chosenCells), length(unique(nextCellsType[, "id"])))
expect_equivalent(NROW(chosenCells), NLcount(dispersingInd))
}
}
# Lynx memory
chosenMat <- chosenCells[chosenCells[, "cellType"] == 2, , drop = FALSE]
if(NROW(chosenMat) != 0) {
dispersingIndMat <- turtle(turtles = dispersingInd, who = dispersingID[chosenMat[, "id"]])
dispersingIndMatnSteps <- dispersingIndMat@.Data[, "nMat"]
#dispersingInd <- NLset(turtles = dispersingInd, agents = dispersingIndMat, var = "nMat",
#                       val = dispersingIndMatnSteps + 1)
dispersingInd@.Data[match(dispersingIndMat@.Data[, "who"],
dispersingInd@.Data[, "who"]), "nMat"] <- as.numeric(dispersingIndMatnSteps + 1) # faster
# Use memory to find a dispersal cell
if(sum(dispersingIndMatnSteps + 1 == nMatMax) != 0) { # GB_change P(sim)$nMatMax
chosenCells <- as.data.frame(chosenCells)
chosenCells[chosenCells[, "cellType"] == 2, c("pxcor", "pycor")][
dispersingIndMatnSteps + 1 == nMatMax, ] <- dispersingIndMat[ # GB_change P(sim)$nMatMax
dispersingIndMatnSteps + 1 == nMatMax]@.Data[, c("lastDispX", "lastDispY")] # GB_change P(sim)$nMatMax
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_equivalent(of(agents = NLwith(agents = dispersingInd, var = "nMat", val = nMatMax), # GB_change P(sim)$nMatMax
var = "who"),
of(agents = dispersingIndMat[dispersingIndMatnSteps + 1 == nMatMax], # GB_change P(sim)$nMatMax
var = "who"))
expect_equivalent(of(agents = NLwith(agents = dispersingInd, var = "nMat", val = nMatMax), # GB_change P(sim)$nMatMax
var = c("lastDispX", "lastDispY")),
dispersingIndMat[dispersingIndMatnSteps + 1 == nMatMax]@.Data[ # GB_change P(sim)$nMatMax
, c("lastDispX", "lastDispY")])
}
# Reset nMat
dispersingIndNMatMax <- NLwith(agents = dispersingInd, var = "nMat", val = nMatMax) # GB_change P(sim)$nMatMax
#dispersingInd <- NLset(turtles = dispersingInd, agents = dispersingIndNMatMax, var = "nMat",
#                       val = 0)
dispersingInd@.Data[match(dispersingIndNMatMax@.Data[, "who"], dispersingInd@.Data[, "who"]), "nMat"] <- as.numeric(0) # faster
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
lastDispCell <- of(agents = NLwith(agents = dispersingInd, var = "nMat", val = nMatMax), # GB_change P(sim)$nMatMax
var = c("lastDispX", "lastDispY"))
expect_equivalent(sum(is.na(lastDispCell)), 0)
expect_true(all(of(agents = dispersingInd, var = "nMat") < nMatMax)) # GB_change P(sim)$nMatMax
}
}
}
# Update "lastDispX" and "lastDispY"
chosenDisp <- chosenCells[chosenCells[, "cellType"] %in% c(4, 3), , drop = FALSE]
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_equivalent(NROW(chosenMat) + NROW(chosenDisp), length(unique(chosenCells[, "id"])))
}
if(NROW(chosenDisp) != 0) {
dispersingIndDisp <- turtle(turtles = dispersingInd,
who = dispersingID[chosenDisp[, "id"]])
dispersingInd <- NLset(turtles = dispersingInd, agents = dispersingIndDisp,
var = c("lastDispX", "lastDispY", "nMat"),
val = cbind(lastDispX = chosenDisp[, "pxcor"],
lastDispY = chosenDisp[, "pycor"],
nMat = 0))
}
# Movement
chosenCellsCoords <- cbind(pxcor = chosenCells[, "pxcor"], pycor = chosenCells[, "pycor"])
dispersingInd <- face(turtles = dispersingInd, agents2 = chosenCellsCoords)
# Individuals that went back to their last known dispersal cell
#stop()
if(NLcount(dispersingIndNMatMax) != 0){
dispersingIndNMatMaxHead <- of(agents = dispersingIndNMatMax, var = "heading")
headChoice <- sapply(dispersingIndNMatMaxHead,
function(x) {
which.min(abs(c(0, 45, 90, 135, 180, 225, 270, 315) - x))
})
#dispersingInd <- NLset(turtles = dispersingInd, agents = dispersingIndNMatMax,
#                       var = "heading", val = c(0, 45, 90, 135, 180, 225, 270, 315)[headChoice])
dispersingInd@.Data[match(dispersingIndNMatMax@.Data[, "who"],
dispersingInd@.Data[, "who"]), "heading"] <- as.numeric(c(0, 45, 90, 135, 180, 225, 270, 315)[headChoice]) # faster
# Reset dispersingIndNMatMax
dispersingIndNMatMax <- noTurtles()
}
#stop()
dispersingInd <- moveTo(turtles = dispersingInd, agents = chosenCellsCoords)
# chosenCellsCoords are the dispersers new locations
# Put + 1 on these cells because dispersers stepped on them
sim$connectivityMap <- NLset(world = sim$connectivityMap, agents = chosenCellsCoords,
val = of(world = sim$connectivityMap, agents = chosenCellsCoords) + 1)
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_equivalent(chosenCellsCoords, patchHere(world = sim$habitatMap,
turtles = dispersingInd))
expect_equivalent(currCells[, c("pxcor", "pycor")], of(agents = dispersingInd,
var = c("prevX", "prevY")))
expect_equivalent(patchHere(world = sim$habitatMap, turtles = dispersingInd)
[chosenCells[, "cellType"] %in% c(3, 4), ],
of(agents = dispersingInd, var = c("lastDispX", "lastDispY"))
[chosenCells[, "cellType"] %in% c(3, 4), ])
}
# Spatial mortality influenced by roads
roadMort <- of(world = sim$roadMortMap, agents = chosenCellsCoords)
# Add the correction factor for the dispersers
deathRoad <- rbinom(n = length(roadMort), size = 1, prob = (roadMort / corrFactorDisp)) # GB_change P(sim)$corrFactorDisp
# Do not kill the dispersers the first year of simulation
# because all individuals from the initial population are dispersers
## INITIAL MORTALITY
if(floor(time(sim))[1] == start(sim, "year")[1]){
deathRoad <- rep(0, length(roadMort))
}
sim$nColl <- rbind(sim$nColl, data.frame(ncoll = sum(deathRoad),
time = floor(time(sim))[1]))
deathRoad[roadMort == 1] <- 1 # mortality of 1 on the borders (roadMort == 1) needs to be forced
deadWhoRoad <- dispersingID[deathRoad == 1]
if(length(deadWhoRoad) != 0){
sim$deadLynxColl[[time(sim, "year")[1]]] <-
turtleSet(sim$deadLynxColl[[time(sim, "year")[1]]],
turtle(turtles = dispersingInd, who = deadWhoRoad)) # add the new lynx dead by collisions
}
dispersingInd <- die(turtles = dispersingInd, who = deadWhoRoad)
sim$aliveDispersingIndID <- dispersingInd@.Data[, "who"]
sim$deadDisp[sim$deadDisp$time == floor(time(sim))[1], "nDispDeadColl"] <-
sim$deadDisp[sim$deadDisp$time == floor(time(sim))[1], "nDispDeadColl"] +
length(deadWhoRoad)
#stop()
# Territory search
disperser <- turtleSet(dispersingInd, nonDispersingInd)
disperser <- sortOn(agents = disperser, var = "who")
disperserID <- disperser@.Data[, "who"]
sim$lynx <- turtleSet(disperser, nonDisperser)
sim$lynx <- sortOn(agents = sim$lynx, var = "who")
#stop()
#source("C:/Users/gbal/Desktop/lynx.ibm/appendix_lynxIBM/c2.searchterritory.defunc.r", print.eval = TRUE)
##source("C:/Users/gbal/Desktop/lynx.ibm/appendix_lynxIBM/c1.searchterritory.func.r")
##start.searchTerr <- Sys.time()
##sim <- searchTerritory(sim)
#print(paste('searchTerr', start.searchTerr - Sys.time()))
#disperser <- turtle(turtles = sim$lynx, who = disperserID)
#nonDisperser <- turtle(turtles = sim$lynx, who = nonDisperserID)
#} # end of if(NLcount(dispersingInd) != 0){
#} # end of if(NLcount(disperser) != 0)
#} # end of number of steps during the day
#}
disp <- turtle(turtles = sim$lynx, who = sim$aliveDispersingIndID)
disp
if(NLcount(disp) != 0) {
# Female dispersers
dispFem <- NLwith(agents = disp, var = "sex", val = "F")
if(NLcount(dispFem) != 0) {
dispFemID <- dispFem@.Data[, "who"]
# Shuffle dispFemID so that it's not always the smallest IDs (i.e., the oldest individuals) that go first
dispFemID <- dispFemID[sample(length(dispFemID))]
searchingFemID <- dispFemID[2]
#for(searchingFemID in dispFemID) {
# To build territory = empty cells of breeding type (= 4)=
searchingFemCell <- patchHere(world = sim$habitatMap, turtles = turtle(turtles = sim$lynx, who = searchingFemID))
#searchingFemCellType <- of(world = sim$habitatMap, agents = searchingFemCell)
searchingFemCellType <- sim$habitatMap[searchingFemCell[, 1], searchingFemCell[, 2]] # faster
#searchingFemCellAvail <- of(world = sim$terrMap, agents = searchingFemCell)
searchingFemCellAvail <- sim$terrMap[searchingFemCell[, 1], searchingFemCell[, 2]] # faster
searchingFemCellType <- 4 #
#if(searchingFemCellType == 4 & is.na(searchingFemCellAvail)){ # current position
#terrValues <- of(world = sim$terrMap, agents = patches(sim$terrMap))
terrValues <- as.numeric(t(sim$terrMap@.Data)) # faster
availCellsUpdatedRas <- sim$availCellsRas
occupiedCells <- which(!is.na(terrValues))
availCellsUpdatedRas[occupiedCells] <- 0
# Spread from the female position (loci) to available contiguous cells
# Find on which territory the female is
terrSizeName <- of(world = sim$popDist, agents = patchHere(world = sim$popDist, turtles = turtle(turtles = sim$lynx, who = searchingFemID)))
# And assign the territory size according to her position
if(terrSizeName == 1){
terrSize <- round(coreTerrSizeFAlps)
}
if(terrSizeName == 2){
terrSize <- round(coreTerrSizeFJura)
}
if(terrSizeName == 3){
terrSize <- round(coreTerrSizeFVosgesPalatinate)
}
if(terrSizeName == 4){
terrSize <- round(coreTerrSizeFBlackForest)
}
#which(availCellsUpdatedRas[,] == 0, arr.ind = TRUE)
#terrDT <- spread(landscape = availCellsUpdatedRas,
#availCellsUpdatedRas[520, 10] <- NA
dim.1.spredf <- 1
if(pick.new.values.spred){
while(dim.1.spredf <= 96){
x.picked <- sample.int(sim$habitatMap@maxPxcor, 1)
y.picked <- sample.int(sim$habitatMap@maxPycor, 1)
spread.res <- spread(landscape = availCellsUpdatedRas,
loci = cellFromPxcorPycor(world = sim$habitatMap,
pxcor = x.picked,#10,#searchingFemCell[, 1],
pycor = y.picked),#520),#searchingFemCell[, 2]),
spreadProb = availCellsUpdatedRas,
maxSize = terrSize,
returnIndices = TRUE,
quick = TRUE)
#spread.res
dim.1.spredf <- spread.res %>% dim %>% `[`(1)
}
}
stop()
spread.res
spread(landscape = availCellsUpdatedRas,
loci = cellFromPxcorPycor(world = sim$habitatMap,
pxcor = x.picked,#searchingFemCell[, 1],
pycor = y.picked),#searchingFemCell[, 2]),
spreadProb = availCellsUpdatedRas, maxSize = terrSize, returnIndices = TRUE,
quick = TRUE)
terrCells <- unique(terrDT$indices) # cells of the built territory
if(length(terrCells) == terrSize) {
newTerrCells <- PxcorPycorFromCell(world = sim$habitatMap, cellNum = terrCells)
# Test
if(PtestON == TRUE) {
expect_true(all(is.na(of(world = sim$terrMap, agents = newTerrCells))))
}
# Claim the territory
sim$terrMap <- NLset(world = sim$terrMap, agents = newTerrCells, val = searchingFemID)
# Mortality probability in the territory
#probMortRdTerr <- of(world = sim$roadMortMap, agents = newTerrCells)
probMortRdTerr <- sim$roadMortMap[newTerrCells[, 1], newTerrCells[, 2]] # faster
sim$lynx <- NLset(turtles = sim$lynx, agents = turtle(turtles = sim$lynx, who = searchingFemID),
var = c("status", "rdMortTerr"),
val = cbind(status = "res", rdMortTerr = mean(probMortRdTerr)))
# Save the data about the new residents
if(length(searchingFemID) != 0){
sim$resLynx[[time(sim, "year")[1]]] <- turtleSet(sim$resLynx[[time(sim, "year")[1]]], turtle(turtles = sim$lynx, who = searchingFemID))
sim$timeRes <- rbind(sim$timeRes, data.frame(who = searchingFemID, year =  time(sim, "year")[1], time = sim$day))
}
# Male around to claim the female?
# Check for a male on an area equal to the home range size (95 % kernel density) of the males in the population
# Extract the distance to which look for a male as the radius of its home range size
if(terrSizeName == 1){
maxDistMale <- sqrt(terrSizeMAlps/pi)
}
if(terrSizeName == 2){
maxDistMale <- sqrt(terrSizeMJura/pi)
}
if(terrSizeName == 3){
maxDistMale <- sqrt(terrSizeMVosgesPalatinate/pi)
}
if(terrSizeName == 4){
maxDistMale <- sqrt(terrSizeMBlackForest/pi)
}
neighbTerrCells <- NetLogoR::inRadius(agents = turtle(turtles = sim$lynx, who = searchingFemID), radius = maxDistMale,
agents2 = patches(sim$habitatMap), world = sim$habitatMap, torus = FALSE)
#neighbTerrCells <- unique(of(world = sim$terrMap, agents = neighbTerrCells))
neighbTerrCells <- unique(sim$terrMap[neighbTerrCells[, 1], neighbTerrCells[, 2]]) # faster
otherFemTerr <- neighbTerrCells[!is.na(neighbTerrCells) & neighbTerrCells != searchingFemID]
if(length(otherFemTerr) != 0) {
otherFem <- turtle(turtles = sim$lynx, who = otherFemTerr)
infoOtherFem <- otherFem@.Data[, "maleID"]
infoOtherFem <- infoOtherFem[!is.na(infoOtherFem)]
otherMal <- turtle(turtles = sim$lynx, who = infoOtherFem)
infoOtherMal <- otherMal@.Data[, "nFem"]
if(length(infoOtherFem[infoOtherMal < 3]) != 0){
# Calculate the distances between the new female resident and all the available males
distFemaleMales <- NetLogoR::NLdist(agents = turtle(turtles = sim$lynx, who = searchingFemID),
agents2 = turtle(turtles = sim$lynx, who = infoOtherFem[infoOtherMal < 3]),
torus = FALSE)
selectedMal <- ifelse(length(infoOtherFem[infoOtherMal < 3]) == 1,
infoOtherFem[infoOtherMal < 3],
# Select the closest male if there are several available
infoOtherFem[infoOtherMal < 3][which.min(distFemaleMales)])
# Associate the male to the female
sim$lynx <- NLset(turtles = sim$lynx, agents = turtle(turtles = sim$lynx, who = searchingFemID),
var = "maleID", val = selectedMal)
selectedMalInd <- turtle(turtles = sim$lynx, who = selectedMal)
sim$lynx <- NLset(turtles = sim$lynx, agents = selectedMalInd, var = "nFem",
val = selectedMalInd@.Data[, "nFem"] + 1)
}
}
} # end if(length(terrCells) == terrSize)
} # end if(searchingFemCellType == 4 & is.na(searchingFemCellAvail))
} # end for(searchingFemID in dispFemID)
require(inline)
require(Rcpp)
require(RcppArmadillo)
require(tryCatchLog)
#require(futile.logger)
#options("tryCatchLog.write.error.dump.file" = TRUE)
# work on search territory part ====================================================
lynx.gb <- sim$lynx[,]
lynx.gb$steps <- NULL # drop it because created within cpp
habitatMap.gb <- sim$habitatMap@.Data[,] # x coords are on columns and y on lines
terrMap.gb <- sim$terrMap@.Data[,]
availCellsUpdatedRas.gb <- sim$availCellsRas %>% as.matrix() # in fact before update
popDist.gb <- sim$popDist@.Data
trick <- c(1, 1)
sourceCpp("dispersalGBcpp.cpp")
outputs.cpp <- dispersalGB(
lynx_r = lynx.gb,
lynx_list = lynx.gb %>% as.data.frame %>% as.list,
sMaxPs = sMaxPs,
HabitatMap = habitatMap.gb,
pMat = pMat, #round(1/9, 2)  #pMat
pCorr = pCorr,
nMatMax = nMatMax,
connectivityMap = sim$connectivityMap@.Data[,],
roadMortMap = sim$roadMortMap@.Data[,],
corrFactorDisp = corrFactorDisp,
floorTimeSim = floor(time(sim))[1],
startSimYear = start(sim, "year")[1],
ncoll_ncoll = sim$nColl$ncoll,
ncoll_time = sim$nColl$time,
deadLynxColl = sim$deadLynxColl[[time(sim, "year")[1]]][,] %>% `[`(,c('who', "steps", "heading", "lastDispX", "lastDispY")),
deadDisp = sim$deadDisp[,],
TerrMap = sim$terrMap@.Data[,],  # bits for searchterritory,
availCellsUpdatedRas = sim$availCellsRas %>% as.matrix,
popDist = sim$popDist@.Data[,],
coreTerrSizeFAlps = coreTerrSizeFAlps,
coreTerrSizeFJura = coreTerrSizeFJura,
coreTerrSizeFVosgesPalatinate = coreTerrSizeFVosgesPalatinate,
coreTerrSizeFBlackForest = coreTerrSizeFBlackForest,
returnDistances = FALSE,
allowOverlap = FALSE
)
outputs.cpp
require(inline)
require(Rcpp)
require(RcppArmadillo)
require(tryCatchLog)
#require(futile.logger)
#options("tryCatchLog.write.error.dump.file" = TRUE)
# work on search territory part ====================================================
lynx.gb <- sim$lynx[,]
lynx.gb$steps <- NULL # drop it because created within cpp
habitatMap.gb <- sim$habitatMap@.Data[,] # x coords are on columns and y on lines
terrMap.gb <- sim$terrMap@.Data[,]
availCellsUpdatedRas.gb <- sim$availCellsRas %>% as.matrix() # in fact before update
popDist.gb <- sim$popDist@.Data
trick <- c(1, 1)
sourceCpp("dispersalGBcpp.cpp")
outputs.cpp <- dispersalGB(
lynx_r = lynx.gb,
sMaxPs = sMaxPs,
HabitatMap = habitatMap.gb,
pMat = pMat, #round(1/9, 2)  #pMat
pCorr = pCorr,
nMatMax = nMatMax,
connectivityMap = sim$connectivityMap@.Data[,],
roadMortMap = sim$roadMortMap@.Data[,],
corrFactorDisp = corrFactorDisp,
floorTimeSim = floor(time(sim))[1],
startSimYear = start(sim, "year")[1],
ncoll_ncoll = sim$nColl$ncoll,
ncoll_time = sim$nColl$time,
deadLynxColl = sim$deadLynxColl[[time(sim, "year")[1]]][,] %>% `[`(,c('who', "steps", "heading", "lastDispX", "lastDispY")),
deadDisp = sim$deadDisp[,],
TerrMap = sim$terrMap@.Data[,],  # bits for searchterritory,
availCellsUpdatedRas = sim$availCellsRas %>% as.matrix,
popDist = sim$popDist@.Data[,],
coreTerrSizeFAlps = coreTerrSizeFAlps,
coreTerrSizeFJura = coreTerrSizeFJura,
coreTerrSizeFVosgesPalatinate = coreTerrSizeFVosgesPalatinate,
coreTerrSizeFBlackForest = coreTerrSizeFBlackForest,
returnDistances = FALSE,
allowOverlap = FALSE
)
require(inline)
require(Rcpp)
require(RcppArmadillo)
require(tryCatchLog)
#require(futile.logger)
#options("tryCatchLog.write.error.dump.file" = TRUE)
# work on search territory part ====================================================
lynx.gb <- sim$lynx[,]
lynx.gb$steps <- NULL # drop it because created within cpp
habitatMap.gb <- sim$habitatMap@.Data[,] # x coords are on columns and y on lines
terrMap.gb <- sim$terrMap@.Data[,]
availCellsUpdatedRas.gb <- sim$availCellsRas %>% as.matrix() # in fact before update
popDist.gb <- sim$popDist@.Data
trick <- c(1, 1)
sourceCpp("dispersalGBcpp.cpp")
outputs.cpp <- dispersalGB(
lynx_r = lynx.gb,
sMaxPs = sMaxPs,
HabitatMap = habitatMap.gb,
pMat = pMat, #round(1/9, 2)  #pMat
pCorr = pCorr,
nMatMax = nMatMax,
connectivityMap = sim$connectivityMap@.Data[,],
roadMortMap = sim$roadMortMap@.Data[,],
corrFactorDisp = corrFactorDisp,
floorTimeSim = floor(time(sim))[1],
startSimYear = start(sim, "year")[1],
ncoll_ncoll = sim$nColl$ncoll,
ncoll_time = sim$nColl$time,
deadLynxColl = sim$deadLynxColl[[time(sim, "year")[1]]][,] %>% `[`(,c('who', "steps", "heading", "lastDispX", "lastDispY")),
deadDisp = sim$deadDisp[,],
TerrMap = sim$terrMap@.Data[,],  # bits for searchterritory,
availCellsUpdatedRas = sim$availCellsRas %>% as.matrix,
popDist = sim$popDist@.Data[,],
coreTerrSizeFAlps = coreTerrSizeFAlps,
coreTerrSizeFJura = coreTerrSizeFJura,
coreTerrSizeFVosgesPalatinate = coreTerrSizeFVosgesPalatinate,
coreTerrSizeFBlackForest = coreTerrSizeFBlackForest,
returnDistances = FALSE,
allowOverlap = FALSE
)
require(inline)
require(Rcpp)
require(RcppArmadillo)
require(tryCatchLog)
#require(futile.logger)
#options("tryCatchLog.write.error.dump.file" = TRUE)
# work on search territory part ====================================================
lynx.gb <- sim$lynx[,]
lynx.gb$steps <- NULL # drop it because created within cpp
habitatMap.gb <- sim$habitatMap@.Data[,] # x coords are on columns and y on lines
terrMap.gb <- sim$terrMap@.Data[,]
availCellsUpdatedRas.gb <- sim$availCellsRas %>% as.matrix() # in fact before update
popDist.gb <- sim$popDist@.Data
trick <- c(1, 1)
sourceCpp("dispersalGBcpp.cpp")
outputs.cpp <- dispersalGB(
lynx_r = lynx.gb,
sMaxPs = sMaxPs,
HabitatMap = habitatMap.gb,
pMat = pMat, #round(1/9, 2)  #pMat
pCorr = pCorr,
nMatMax = nMatMax,
connectivityMap = sim$connectivityMap@.Data[,],
roadMortMap = sim$roadMortMap@.Data[,],
corrFactorDisp = corrFactorDisp,
floorTimeSim = floor(time(sim))[1],
startSimYear = start(sim, "year")[1],
ncoll_ncoll = sim$nColl$ncoll,
ncoll_time = sim$nColl$time,
deadLynxColl = sim$deadLynxColl[[time(sim, "year")[1]]][,] %>% `[`(,c('who', "steps", "heading", "lastDispX", "lastDispY")),
deadDisp = sim$deadDisp[,],
TerrMap = sim$terrMap@.Data[,],  # bits for searchterritory,
availCellsUpdatedRas = sim$availCellsRas %>% as.matrix,
popDist = sim$popDist@.Data[,],
coreTerrSizeFAlps = coreTerrSizeFAlps,
coreTerrSizeFJura = coreTerrSizeFJura,
coreTerrSizeFVosgesPalatinate = coreTerrSizeFVosgesPalatinate,
coreTerrSizeFBlackForest = coreTerrSizeFBlackForest,
returnDistances = FALSE,
allowOverlap = FALSE
)
outputs.cpp
require(inline)
require(Rcpp)
require(RcppArmadillo)
require(tryCatchLog)
#require(futile.logger)
#options("tryCatchLog.write.error.dump.file" = TRUE)
# work on search territory part ====================================================
lynx.gb <- sim$lynx[,]
lynx.gb$steps <- NULL # drop it because created within cpp
habitatMap.gb <- sim$habitatMap@.Data[,] # x coords are on columns and y on lines
terrMap.gb <- sim$terrMap@.Data[,]
availCellsUpdatedRas.gb <- sim$availCellsRas %>% as.matrix() # in fact before update
popDist.gb <- sim$popDist@.Data
trick <- c(1, 1)
sourceCpp("dispersalGBcpp.cpp")
outputs.cpp <- dispersalGB(
lynx_r = lynx.gb,
sMaxPs = sMaxPs,
HabitatMap = habitatMap.gb,
pMat = pMat, #round(1/9, 2)  #pMat
pCorr = pCorr,
nMatMax = nMatMax,
connectivityMap = sim$connectivityMap@.Data[,],
roadMortMap = sim$roadMortMap@.Data[,],
corrFactorDisp = corrFactorDisp,
floorTimeSim = floor(time(sim))[1],
startSimYear = start(sim, "year")[1],
ncoll_ncoll = sim$nColl$ncoll,
ncoll_time = sim$nColl$time,
deadLynxColl = sim$deadLynxColl[[time(sim, "year")[1]]][,] %>% `[`(,c('who', "steps", "heading", "lastDispX", "lastDispY")),
deadDisp = sim$deadDisp[,],
TerrMap = sim$terrMap@.Data[,],  # bits for searchterritory,
availCellsUpdatedRas = sim$availCellsRas %>% as.matrix,
popDist = sim$popDist@.Data[,],
coreTerrSizeFAlps = coreTerrSizeFAlps,
coreTerrSizeFJura = coreTerrSizeFJura,
coreTerrSizeFVosgesPalatinate = coreTerrSizeFVosgesPalatinate,
coreTerrSizeFBlackForest = coreTerrSizeFBlackForest,
returnDistances = FALSE,
allowOverlap = FALSE
)
outputs.cpp
