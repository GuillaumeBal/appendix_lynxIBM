putois", "renard", "sanglier")
gibier.eau <- c("barge à queue noire", "barge rousse", "bécasseau maubèche", "bécassine des marais", "bécassine sourde,
canard chipeau", "canard colvert", "canard pilet", "canard siffleur", "canard souchet", "chevalier aboyeur,
chevalier arlequin", "chevalier combattant", "chevalier gambette", "courlis cendré", "courlis corlieu,
eider à duvet", "foulque macroule", "fuligule milouin", "fuligule milouinan", "fuligule morillon,
garrot à l'oeil d'or", "harelde de Miquelon", "huîtrier pie", "macreuse brune", "macreuse noire", "nette rousse,
oie cendrée", "oie des moissons", "oie rieuse", "pluvier argenté", "pluvier doré", "poule d'eau", "râle d'eau,
sarcelle d'été", "sarcelle d'hiver", "vanneau huppé")
oiseaux.passage <- c("alouette des champs", "bécasse des bois", "caille des blés", "grive draine", "grive litorne", "grive mauvis,
grive musicienne", "merle noir", "pigeon biset", "pigeon colombin", "pigeon ramier", "tourterelle des bois,
tourterelle turque", "vanneau huppé")
huntabke.species <- data.frame(vernaculaire = c(oiseaux.passage, oiseaux.sedentaire, gibier.eau, mammiferes.sedentaire))
rm(list = ls())
require('magrittr')
# list of huntable species ======================================================================================================
#https://www.legifrance.gouv.fr/loda/id/JORFTEXT000000296288/2021-01-17/
oiseaux.sedentaire <-  c("colin", "corbeau freux", "corneille noire", "étourneau sansonnet", "faisan de chasse", "geai des chênes", "
gélinotte des bois", "lagopède alpin", "perdrix bartavelle", "perdrix rouge", "perdrix grise", "
pie bavarde", "tétras lyre", "tétras urogalle")
mammiferes.sedentaire <- c("blaireau", "belette", "cerf élaphe", "cerf sika", "chamois isard", "chevreuil", "daim", "fouine", "hermine,
lapin de garenne", "lièvre brun", "lièvre variable", "marmotte", "martre", "mouflon méditerranéen,
putois", "renard", "sanglier")
gibier.eau <- c("barge à queue noire", "barge rousse", "bécasseau maubèche", "bécassine des marais", "bécassine sourde,
canard chipeau", "canard colvert", "canard pilet", "canard siffleur", "canard souchet", "chevalier aboyeur,
chevalier arlequin", "chevalier combattant", "chevalier gambette", "courlis cendré", "courlis corlieu,
eider à duvet", "foulque macroule", "fuligule milouin", "fuligule milouinan", "fuligule morillon,
garrot à l'oeil d'or", "harelde de Miquelon", "huîtrier pie", "macreuse brune", "macreuse noire", "nette rousse,
oie cendrée", "oie des moissons", "oie rieuse", "pluvier argenté", "pluvier doré", "poule d'eau", "râle d'eau,
sarcelle d'été", "sarcelle d'hiver", "vanneau huppé")
oiseaux.passage <- c("alouette des champs", "bécasse des bois", "caille des blés", "grive draine", "grive litorne", "grive mauvis,
grive musicienne", "merle noir", "pigeon biset", "pigeon colombin", "pigeon ramier", "tourterelle des bois,
tourterelle turque", "vanneau huppé")
huntable.species <- data.frame(vernaculaire = c(oiseaux.passage, oiseaux.sedentaire, gibier.eau, mammiferes.sedentaire))
getwd()
rm(list = ls())
require('magrittr')
"C:/Users/gbal/Desktop" %>% dir
0.67*0.464*2.028
0.67 ^ 2
2.028*0.464
rm(list = ls())
require(magrittr)
wd <- "C:/Users/gbal/Desktop/lynx.ibm/appendix_lynxIBM" %T>% setwd()
# agent matrix
load("lynx.sim.gb.Rdata")
#lynx.sim.gb$lynxIBMrun
#attach(lynx.sim.gb)
load('../calibr.sarah/calibr1/lynxIBMrun_10319.RData')
lynxIBMinit <- lynx.sim.gb$lynxIBMinit
# IBM linked packages
reqdPkgs = list("NetLogoR", "testthat", "SpaDES", "raster", "randomcoloR", "data.table", "dplyr", "doBy")
reqdPkgs %>% unlist %>% sapply(., FUN = function(x){require(x, character.only = TRUE)})
# some data from outputs
sim <- lynxIBMrun#lynxIBMinit
# arguments Sarah to get back from inits part of loaded run data
sMaxPs <- P(lynxIBMinit)$lynxIBM$sMaxPs #45
testON <- P(lynxIBMinit)$lynxIBM$testON #TRUE
pMat <- P(lynxIBMinit)$lynxIBM$pMat #0.03
pCorr <- P(lynxIBMinit)$lynxIBM$pCorr #0.5
nMatMax <- P(lynxIBMinit)$lynxIBM$nMatMax #10
corrFactorDisp <- P(lynxIBMinit)$lynxIBM$corrFactorDisp #250
# within searchTerritory
coreTerrSizeFAlps <- P(lynxIBMinit)$lynxIBM$coreTerrSizeFAlps #97
coreTerrSizeFJura <- P(lynxIBMinit)$lynxIBM$coreTerrSizeFJura #126
coreTerrSizeFVosgesPalatinate <- P(lynxIBMinit)$lynxIBM$coreTerrSizeFVosgesPalatinate #126
coreTerrSizeFBlackForest <- P(lynxIBMinit)$lynxIBM$coreTerrSizeFBlackForest #126
terrSizeMAlps <- P(lynxIBMinit)$lynxIBM$terrSizeMAlps #159
terrSizeMJura <- P(lynxIBMinit)$lynxIBM$terrSizeMJura #270
terrSizeMVosgesPalatinate <- P(lynxIBMinit)$lynxIBM$terrSizeMVosgesPalatinate #270
terrSizeMBlackForest <- P(lynxIBMinit)$lynxIBM$terrSizeMBlackForest #270
#"C:/Users/gbal/Desktop/lynx.ibm/searchterritory.func.r" %>%
#  source()
pick.new.values.spred <- FALSE
if(!pick.new.values.spred){
x.picked <- 223
y.picked <- 313
}
# here is where the function start , dispersal <- function(sim) { ===================================================
# stops before executing part to code within cpp
disperser <- NLwith(agents = sim$lynx, var = "status", val = "disp")
nDisp <- NLcount(disperser)
nonDisperser <- other(agents = sim$lynx, except = disperser)
nonDisperserID <- nonDisperser@.Data[, "who"]
sim$deadDisp <- rbind(sim$deadDisp, data.frame(nDisp = nDisp, nDispDeadColl = 0, nDispDeadDaily = 0, time = floor(time(sim))[1]))
#if(nDisp != 0) {
# Number of steps dispersers can walk during the day
steps <- sample(x = 1:sMaxPs, size = nDisp, prob = sim$Ps, replace = TRUE) # GB_change P(sim)$sMaxPs
stepsDisp <- 1:max(steps)
#disperser <- NLset(turtles = disperser, agents = disperser, var = "steps", val = steps)
disperser@.Data[, "steps"] <- as.numeric(steps) # faster
#stop()
#{for(step in stepsDisp) {
step <- 2
#if(NLcount(disperser) != 0){ # update of the disperser at each "step" loop
dispersingIndNMatMax <- noTurtles()
# Dispersers which have not reach their max number of steps yet
infoDisp <- of(agents = disperser, var = c("who", "status", "steps"))
dispersingID <- infoDisp[step <= infoDisp[, "steps"] & infoDisp[, "status"] == "disp", "who"]
dispersingInd <- turtle(turtles = disperser, who = dispersingID)
nonDispersingInd <- other(agents = disperser, except = dispersingInd)
# Test
if(testON == TRUE) { #GB_change P(sim)$testON
infoDispersingInd <- of(agents = dispersingInd, var = c("status", "steps"))
expect_true(all(infoDispersingInd[, "status"] == "disp"))
expect_true(all(infoDispersingInd[, "steps"] >= step))
infoNonDispersingInd <- of(agents = nonDispersingInd, var = c("status", "steps"))
if(NLcount(nonDispersingInd) != 0){
expect_true(all(infoNonDispersingInd[, "status"] == "res" |
infoNonDispersingInd[, "steps"] < step))
}
}
#if(NLcount(dispersingInd) != 0){
# Next step in one of the 9 (or less) cells = 8 (or less) neighboring cells + current location
neighCells <- NetLogoR::neighbors(world = sim$habitatMap, agents = dispersingInd, nNeighbors = 8,
torus = FALSE)
currCells <- patchHere(world = sim$habitatMap, turtles = dispersingInd)
currCells <- cbind(currCells, id = 1:NLcount(dispersingInd))
nextCells <- rbind(neighCells, currCells)
# First, selection of cell type with preference for breeding or dispersal over matrix
nextCells <- cbind(nextCells,
cellType = of(world = sim$habitatMap,
agents = nextCells[, c("pxcor", "pycor")]))
nextCellsDT <- as.data.table(nextCells)
cellTypeFreqFull <- nextCellsDT[ , count := .N, by = list(id, cellType)]
cellTypeFreqFull <- cellTypeFreqFull[, c("id", "cellType", "count")]
#setkey(cellTypeFreqFull) # not necessary with dplyr::distinct()
#cellTypeFreq <- as.matrix(unique(cellTypeFreqFull)) # cbind is faster than as.matrix
#cellTypeFreqUnik <- unique(cellTypeFreqFull)
cellTypeFreqUnik <- dplyr::distinct(cellTypeFreqFull) # faster than unique
cellTypeFreq <- cbind(id = cellTypeFreqUnik$id, cellType = cellTypeFreqUnik$cellType,
count = cellTypeFreqUnik$count)
# Test
if(testON == TRUE) { # GB_ change P(sim)$testON
expect_equivalent(sum(cellTypeFreq[, "count"]), NROW(nextCells))
}
withMatrix <- unique(cellTypeFreq[cellTypeFreq[, "cellType"] == 2, "id"])
withoutMatrix <- unique(cellTypeFreq[!cellTypeFreq[, "id"] %in% withMatrix, "id"])
pChooseMatrix <- pMat * cellTypeFreq[cellTypeFreq[, "id"] %in% withMatrix & # GB_change P(sim)$pMat
cellTypeFreq[, "cellType"] == 2, "count"]
choseMatrix <- rbinom(n = length(pChooseMatrix), size = 1, prob = pChooseMatrix)
onlyMat <- unique(cellTypeFreq[, "id"])[
!unique(cellTypeFreq[, "id"]) %in%
unique(cellTypeFreq[cellTypeFreq[, "cellType"] %in% c(3, 4) , "id"])]
nextCellsType <- rbind(nextCells[nextCells[, "cellType"] == 2 &
nextCells[, "id"] %in%
c(withMatrix[choseMatrix == 1], onlyMat), ],
nextCells[nextCells[, "cellType"] %in% c(3, 4) &
nextCells[, "id"] %in% c(withoutMatrix,
withMatrix[choseMatrix == 0]), ])
# Second, selection of cell based on the direction
if(step == 1) { # no correlation
nextCellsTypeDT <- as.data.table(nextCellsType)
nextCellsTypeDTsampled <- nextCellsTypeDT[nextCellsTypeDT[, .I[sample(.N,1)], by = id]$V1]
# chosenCells <- as.matrix(nextCellsTypeDTsampled) # the following line is fater than this one
chosenCells <- cbind(pxcor = nextCellsTypeDTsampled$pxcor, pycor = nextCellsTypeDTsampled$pycor,
id = nextCellsTypeDTsampled$id, cellType = nextCellsTypeDTsampled$cellType)
chosenCells <- chosenCells[order(chosenCells[, "id"]), , drop = FALSE]
# Test
if(testON == TRUE) { #P(sim)$testON
expect_equivalent(NROW(chosenCells), length(unique(chosenCells[, "id"])))
expect_equivalent(NROW(chosenCells), length(unique(nextCellsType[, "id"])))
}
# END step == 1
} else { # movement correlation
dispCell <- cbind(patchHere(world = sim$habitatMap, turtles = dispersingInd),
id = 1:NLcount(dispersingInd))
colnames(dispCell)[c(1, 2)] <- c("pxcorHere", "pycorHere")
#stop()
nextCellsType <- merge(nextCellsType, dispCell)
nextCellsType <- nextCellsType[order(nextCellsType[, "id"]), , drop = FALSE]
# Individuals with a correlated movement
probCorr <- rbinom(n = NLcount(dispersingInd), size = 1, prob = pCorr) # GB_change P(sim)$pCorr
# Individuals without a correlated movement
noCorr <- nextCellsType[nextCellsType[, "id"] %in%
unique(nextCellsType[, "id"])[probCorr == 0], ]
chosenCellsNoCorr <- cbind(pxcor = numeric(), pycor = numeric(),  id = numeric(),
cellType = numeric())
if(length(noCorr) != 0) {
noCorrDT <- as.data.table(noCorr)
# chosenCellsNoCorr <- as.matrix(noCorrDT[noCorrDT[, .I[sample(.N,1)], by = id]$V1]) # the following two lines are faster than this single one line
chosenCellsNoCorrDT <- noCorrDT[noCorrDT[, .I[sample(.N,1)], by = id]$V1]
chosenCellsNoCorr <- cbind(id = chosenCellsNoCorrDT$id, pxcor = chosenCellsNoCorrDT$pxcor,
pycor = chosenCellsNoCorrDT$pycor, cellType = chosenCellsNoCorrDT$cellType,
pxcorHere = chosenCellsNoCorrDT$pxcorHere, pycorHere = chosenCellsNoCorrDT$pycorHere)
chosenCellsNoCorr <- chosenCellsNoCorr[, c("pxcor", "pycor", "id", "cellType")]
}
#stop()
# Individuals with a correlated movement
yesCorr <- unique(nextCellsType[, "id"])[probCorr == 1]
chosenCellsYesCorrSelect <- cbind(pxcor = numeric(), pycor = numeric(),  id = numeric(),
cellType = numeric())
if(length(yesCorr) != 0) {
nextCellsTypeDir <- cbind(nextCellsType[nextCellsType[, "id"] %in% yesCorr, ],
dir = as.numeric(NA))
for(eachYesCorr in yesCorr) {
indYessCorr <- turtle(turtles = dispersingInd, who = dispersingID[eachYesCorr])
#stop()
#source("b2.towards.defunc.r")
#start.towards <- Sys.time()
dirCells <- towards(agents = indYessCorr, agents2 = cbind(
pxcor = nextCellsTypeDir[nextCellsTypeDir[, "id"] == eachYesCorr, "pxcor"],
pycor = nextCellsTypeDir[nextCellsTypeDir[, "id"] == eachYesCorr, "pycor"]),
torus = FALSE)
#print(paste('towards', start.towards - Sys.time()))
nextCellsTypeDir[nextCellsTypeDir[, "id"] == eachYesCorr, "dir"] <-
round(subHeadings(angle1 = indYessCorr@.Data[, "heading"], angle2 = dirCells,
range360 = TRUE))
}
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_true(all(nextCellsTypeDir[, "dir"] %in% c(0, 45, 90, 135, 180, 225, 270, 315)))
expect_equivalent(length(yesCorr), length(unique(nextCellsTypeDir$id)))
}
# Rank the direction as preferences
nextCellsTypeDir <- cbind(nextCellsTypeDir, prefDir = 1)
nextCellsTypeDir[nextCellsTypeDir[, "dir"] %in% c(45, 315), "prefDir"] <- 2
nextCellsTypeDir[nextCellsTypeDir[, "dir"] %in% c(90, 270), "prefDir"] <- 3
nextCellsTypeDir[nextCellsTypeDir[, "dir"] %in% c(135, 225), "prefDir"] <- 4
nextCellsTypeDir[nextCellsTypeDir[, "dir"] == 180, "prefDir"] <- 5
nextCellsTypeDir[nextCellsTypeDir[, "pxcor"] == nextCellsTypeDir[, "pxcorHere"]
& nextCellsTypeDir[, "pycor"] == nextCellsTypeDir[, "pycorHere"],
"prefDir"] <- 3
nextCellsTypeDirDT <- as.data.table(nextCellsTypeDir)
chosenCellsYesCorrDT <- nextCellsTypeDirDT[nextCellsTypeDirDT[, .I[sample(.N,1)],
by = c("id","prefDir")]$V1]
# Select the cell with the smallest rotation
#chosenCellsYesCorrSelect <- as.matrix(chosenCellsYesCorrDT[, .SD[which.min(prefDir)], by = id]) # the two lines after are faster than these two lines
#chosenCellsYesCorrSelect <- chosenCellsYesCorrSelect[, c("pxcor", "pycor", "id", "cellType")]
chosenCellsYesCorrSelectDT <- chosenCellsYesCorrDT[, .SD[which.min(prefDir)], by = id]
chosenCellsYesCorrSelect <- cbind(pxcor = chosenCellsYesCorrSelectDT$pxcor, pycor = chosenCellsYesCorrSelectDT$pycor,
id = chosenCellsYesCorrSelectDT$id, cellType = chosenCellsYesCorrSelectDT$cellType)
}
# Regroup the individuals that had not a correlation movement and the ones that had
chosenCells <- rbind(chosenCellsNoCorr, chosenCellsYesCorrSelect)
chosenCells <- chosenCells[order(chosenCells[, "id"]), , drop = FALSE]
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_equivalent(NROW(chosenCells), length(unique(chosenCells[, "id"])))
expect_equivalent(NROW(chosenCells), length(unique(nextCellsType[, "id"])))
expect_equivalent(NROW(chosenCells), NLcount(dispersingInd))
}
}
# Lynx memory
chosenMat <- chosenCells[chosenCells[, "cellType"] == 2, , drop = FALSE]
if(NROW(chosenMat) != 0) {
dispersingIndMat <- turtle(turtles = dispersingInd, who = dispersingID[chosenMat[, "id"]])
dispersingIndMatnSteps <- dispersingIndMat@.Data[, "nMat"]
#dispersingInd <- NLset(turtles = dispersingInd, agents = dispersingIndMat, var = "nMat",
#                       val = dispersingIndMatnSteps + 1)
dispersingInd@.Data[match(dispersingIndMat@.Data[, "who"],
dispersingInd@.Data[, "who"]), "nMat"] <- as.numeric(dispersingIndMatnSteps + 1) # faster
# Use memory to find a dispersal cell
if(sum(dispersingIndMatnSteps + 1 == nMatMax) != 0) { # GB_change P(sim)$nMatMax
chosenCells <- as.data.frame(chosenCells)
chosenCells[chosenCells[, "cellType"] == 2, c("pxcor", "pycor")][
dispersingIndMatnSteps + 1 == nMatMax, ] <- dispersingIndMat[ # GB_change P(sim)$nMatMax
dispersingIndMatnSteps + 1 == nMatMax]@.Data[, c("lastDispX", "lastDispY")] # GB_change P(sim)$nMatMax
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_equivalent(of(agents = NLwith(agents = dispersingInd, var = "nMat", val = nMatMax), # GB_change P(sim)$nMatMax
var = "who"),
of(agents = dispersingIndMat[dispersingIndMatnSteps + 1 == nMatMax], # GB_change P(sim)$nMatMax
var = "who"))
expect_equivalent(of(agents = NLwith(agents = dispersingInd, var = "nMat", val = nMatMax), # GB_change P(sim)$nMatMax
var = c("lastDispX", "lastDispY")),
dispersingIndMat[dispersingIndMatnSteps + 1 == nMatMax]@.Data[ # GB_change P(sim)$nMatMax
, c("lastDispX", "lastDispY")])
}
# Reset nMat
dispersingIndNMatMax <- NLwith(agents = dispersingInd, var = "nMat", val = nMatMax) # GB_change P(sim)$nMatMax
#dispersingInd <- NLset(turtles = dispersingInd, agents = dispersingIndNMatMax, var = "nMat",
#                       val = 0)
dispersingInd@.Data[match(dispersingIndNMatMax@.Data[, "who"], dispersingInd@.Data[, "who"]), "nMat"] <- as.numeric(0) # faster
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
lastDispCell <- of(agents = NLwith(agents = dispersingInd, var = "nMat", val = nMatMax), # GB_change P(sim)$nMatMax
var = c("lastDispX", "lastDispY"))
expect_equivalent(sum(is.na(lastDispCell)), 0)
expect_true(all(of(agents = dispersingInd, var = "nMat") < nMatMax)) # GB_change P(sim)$nMatMax
}
}
}
# Update "lastDispX" and "lastDispY"
chosenDisp <- chosenCells[chosenCells[, "cellType"] %in% c(4, 3), , drop = FALSE]
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_equivalent(NROW(chosenMat) + NROW(chosenDisp), length(unique(chosenCells[, "id"])))
}
if(NROW(chosenDisp) != 0) {
dispersingIndDisp <- turtle(turtles = dispersingInd,
who = dispersingID[chosenDisp[, "id"]])
dispersingInd <- NLset(turtles = dispersingInd, agents = dispersingIndDisp,
var = c("lastDispX", "lastDispY", "nMat"),
val = cbind(lastDispX = chosenDisp[, "pxcor"],
lastDispY = chosenDisp[, "pycor"],
nMat = 0))
}
# Movement
chosenCellsCoords <- cbind(pxcor = chosenCells[, "pxcor"], pycor = chosenCells[, "pycor"])
dispersingInd <- face(turtles = dispersingInd, agents2 = chosenCellsCoords)
# Individuals that went back to their last known dispersal cell
#stop()
if(NLcount(dispersingIndNMatMax) != 0){
dispersingIndNMatMaxHead <- of(agents = dispersingIndNMatMax, var = "heading")
headChoice <- sapply(dispersingIndNMatMaxHead,
function(x) {
which.min(abs(c(0, 45, 90, 135, 180, 225, 270, 315) - x))
})
#dispersingInd <- NLset(turtles = dispersingInd, agents = dispersingIndNMatMax,
#                       var = "heading", val = c(0, 45, 90, 135, 180, 225, 270, 315)[headChoice])
dispersingInd@.Data[match(dispersingIndNMatMax@.Data[, "who"],
dispersingInd@.Data[, "who"]), "heading"] <- as.numeric(c(0, 45, 90, 135, 180, 225, 270, 315)[headChoice]) # faster
# Reset dispersingIndNMatMax
dispersingIndNMatMax <- noTurtles()
}
#stop()
dispersingInd <- moveTo(turtles = dispersingInd, agents = chosenCellsCoords)
# chosenCellsCoords are the dispersers new locations
# Put + 1 on these cells because dispersers stepped on them
sim$connectivityMap <- NLset(world = sim$connectivityMap, agents = chosenCellsCoords,
val = of(world = sim$connectivityMap, agents = chosenCellsCoords) + 1)
# Test
if(testON == TRUE) { # GB_change P(sim)$testON
expect_equivalent(chosenCellsCoords, patchHere(world = sim$habitatMap,
turtles = dispersingInd))
expect_equivalent(currCells[, c("pxcor", "pycor")], of(agents = dispersingInd,
var = c("prevX", "prevY")))
expect_equivalent(patchHere(world = sim$habitatMap, turtles = dispersingInd)
[chosenCells[, "cellType"] %in% c(3, 4), ],
of(agents = dispersingInd, var = c("lastDispX", "lastDispY"))
[chosenCells[, "cellType"] %in% c(3, 4), ])
}
# Spatial mortality influenced by roads
roadMort <- of(world = sim$roadMortMap, agents = chosenCellsCoords)
# Add the correction factor for the dispersers
deathRoad <- rbinom(n = length(roadMort), size = 1, prob = (roadMort / corrFactorDisp)) # GB_change P(sim)$corrFactorDisp
# Do not kill the dispersers the first year of simulation
# because all individuals from the initial population are dispersers
## INITIAL MORTALITY
if(floor(time(sim))[1] == start(sim, "year")[1]){
deathRoad <- rep(0, length(roadMort))
}
sim$nColl <- rbind(sim$nColl, data.frame(ncoll = sum(deathRoad),
time = floor(time(sim))[1]))
deathRoad[roadMort == 1] <- 1 # mortality of 1 on the borders (roadMort == 1) needs to be forced
deadWhoRoad <- dispersingID[deathRoad == 1]
if(length(deadWhoRoad) != 0){
sim$deadLynxColl[[time(sim, "year")[1]]] <-
turtleSet(sim$deadLynxColl[[time(sim, "year")[1]]],
turtle(turtles = dispersingInd, who = deadWhoRoad)) # add the new lynx dead by collisions
}
dispersingInd <- die(turtles = dispersingInd, who = deadWhoRoad)
sim$aliveDispersingIndID <- dispersingInd@.Data[, "who"]
sim$deadDisp[sim$deadDisp$time == floor(time(sim))[1], "nDispDeadColl"] <-
sim$deadDisp[sim$deadDisp$time == floor(time(sim))[1], "nDispDeadColl"] +
length(deadWhoRoad)
#stop()
# Territory search
disperser <- turtleSet(dispersingInd, nonDispersingInd)
disperser <- sortOn(agents = disperser, var = "who")
disperserID <- disperser@.Data[, "who"]
sim$lynx <- turtleSet(disperser, nonDisperser)
sim$lynx <- sortOn(agents = sim$lynx, var = "who")
#stop()
#source("C:/Users/gbal/Desktop/lynx.ibm/appendix_lynxIBM/c2.searchterritory.defunc.r", print.eval = TRUE)
##source("C:/Users/gbal/Desktop/lynx.ibm/appendix_lynxIBM/c1.searchterritory.func.r")
##start.searchTerr <- Sys.time()
##sim <- searchTerritory(sim)
#print(paste('searchTerr', start.searchTerr - Sys.time()))
#disperser <- turtle(turtles = sim$lynx, who = disperserID)
#nonDisperser <- turtle(turtles = sim$lynx, who = nonDisperserID)
#} # end of if(NLcount(dispersingInd) != 0){
#} # end of if(NLcount(disperser) != 0)
#} # end of number of steps during the day
#}
disp <- turtle(turtles = sim$lynx, who = sim$aliveDispersingIndID)
disp
if(NLcount(disp) != 0) {
# Female dispersers
dispFem <- NLwith(agents = disp, var = "sex", val = "F")
if(NLcount(dispFem) != 0) {
dispFemID <- dispFem@.Data[, "who"]
# Shuffle dispFemID so that it's not always the smallest IDs (i.e., the oldest individuals) that go first
dispFemID <- dispFemID[sample(length(dispFemID))]
searchingFemID <- dispFemID[2]
#for(searchingFemID in dispFemID) {
# To build territory = empty cells of breeding type (= 4)=
searchingFemCell <- patchHere(world = sim$habitatMap, turtles = turtle(turtles = sim$lynx, who = searchingFemID))
#searchingFemCellType <- of(world = sim$habitatMap, agents = searchingFemCell)
searchingFemCellType <- sim$habitatMap[searchingFemCell[, 1], searchingFemCell[, 2]] # faster
#searchingFemCellAvail <- of(world = sim$terrMap, agents = searchingFemCell)
searchingFemCellAvail <- sim$terrMap[searchingFemCell[, 1], searchingFemCell[, 2]] # faster
searchingFemCellType <- 4 #
#if(searchingFemCellType == 4 & is.na(searchingFemCellAvail)){ # current position
#terrValues <- of(world = sim$terrMap, agents = patches(sim$terrMap))
terrValues <- as.numeric(t(sim$terrMap@.Data)) # faster
availCellsUpdatedRas <- sim$availCellsRas
occupiedCells <- which(!is.na(terrValues))
availCellsUpdatedRas[occupiedCells] <- 0
# Spread from the female position (loci) to available contiguous cells
# Find on which territory the female is
terrSizeName <- of(world = sim$popDist, agents = patchHere(world = sim$popDist, turtles = turtle(turtles = sim$lynx, who = searchingFemID)))
# And assign the territory size according to her position
if(terrSizeName == 1){
terrSize <- round(coreTerrSizeFAlps)
}
if(terrSizeName == 2){
terrSize <- round(coreTerrSizeFJura)
}
if(terrSizeName == 3){
terrSize <- round(coreTerrSizeFVosgesPalatinate)
}
if(terrSizeName == 4){
terrSize <- round(coreTerrSizeFBlackForest)
}
#which(availCellsUpdatedRas[,] == 0, arr.ind = TRUE)
#terrDT <- spread(landscape = availCellsUpdatedRas,
#availCellsUpdatedRas[520, 10] <- NA
dim.1.spredf <- 1
if(pick.new.values.spred){
while(dim.1.spredf <= 96){
x.picked <- sample.int(sim$habitatMap@maxPxcor, 1)
y.picked <- sample.int(sim$habitatMap@maxPycor, 1)
spread.res <- spread(landscape = availCellsUpdatedRas,
loci = cellFromPxcorPycor(world = sim$habitatMap,
pxcor = x.picked,#10,#searchingFemCell[, 1],
pycor = y.picked),#520),#searchingFemCell[, 2]),
spreadProb = availCellsUpdatedRas,
maxSize = terrSize,
returnIndices = TRUE,
quick = TRUE)
spread.res
dim.1.spredf <- spread.res %>% dim %>% `[`(1)
}
}
stop()
spread.res
spread(landscape = availCellsUpdatedRas,
loci = cellFromPxcorPycor(world = sim$habitatMap,
pxcor = x.picked,#searchingFemCell[, 1],
pycor = y.picked),#searchingFemCell[, 2]),
spreadProb = availCellsUpdatedRas, maxSize = terrSize, returnIndices = TRUE,
quick = TRUE)
terrCells <- unique(terrDT$indices) # cells of the built territory
if(length(terrCells) == terrSize) {
newTerrCells <- PxcorPycorFromCell(world = sim$habitatMap, cellNum = terrCells)
# Test
if(PtestON == TRUE) {
expect_true(all(is.na(of(world = sim$terrMap, agents = newTerrCells))))
}
# Claim the territory
sim$terrMap <- NLset(world = sim$terrMap, agents = newTerrCells, val = searchingFemID)
# Mortality probability in the territory
#probMortRdTerr <- of(world = sim$roadMortMap, agents = newTerrCells)
probMortRdTerr <- sim$roadMortMap[newTerrCells[, 1], newTerrCells[, 2]] # faster
sim$lynx <- NLset(turtles = sim$lynx, agents = turtle(turtles = sim$lynx, who = searchingFemID),
var = c("status", "rdMortTerr"),
val = cbind(status = "res", rdMortTerr = mean(probMortRdTerr)))
# Save the data about the new residents
if(length(searchingFemID) != 0){
sim$resLynx[[time(sim, "year")[1]]] <- turtleSet(sim$resLynx[[time(sim, "year")[1]]], turtle(turtles = sim$lynx, who = searchingFemID))
sim$timeRes <- rbind(sim$timeRes, data.frame(who = searchingFemID, year =  time(sim, "year")[1], time = sim$day))
}
# Male around to claim the female?
# Check for a male on an area equal to the home range size (95 % kernel density) of the males in the population
# Extract the distance to which look for a male as the radius of its home range size
if(terrSizeName == 1){
maxDistMale <- sqrt(terrSizeMAlps/pi)
}
if(terrSizeName == 2){
maxDistMale <- sqrt(terrSizeMJura/pi)
}
if(terrSizeName == 3){
maxDistMale <- sqrt(terrSizeMVosgesPalatinate/pi)
}
if(terrSizeName == 4){
maxDistMale <- sqrt(terrSizeMBlackForest/pi)
}
neighbTerrCells <- NetLogoR::inRadius(agents = turtle(turtles = sim$lynx, who = searchingFemID), radius = maxDistMale,
agents2 = patches(sim$habitatMap), world = sim$habitatMap, torus = FALSE)
#neighbTerrCells <- unique(of(world = sim$terrMap, agents = neighbTerrCells))
neighbTerrCells <- unique(sim$terrMap[neighbTerrCells[, 1], neighbTerrCells[, 2]]) # faster
otherFemTerr <- neighbTerrCells[!is.na(neighbTerrCells) & neighbTerrCells != searchingFemID]
if(length(otherFemTerr) != 0) {
otherFem <- turtle(turtles = sim$lynx, who = otherFemTerr)
infoOtherFem <- otherFem@.Data[, "maleID"]
infoOtherFem <- infoOtherFem[!is.na(infoOtherFem)]
otherMal <- turtle(turtles = sim$lynx, who = infoOtherFem)
infoOtherMal <- otherMal@.Data[, "nFem"]
if(length(infoOtherFem[infoOtherMal < 3]) != 0){
# Calculate the distances between the new female resident and all the available males
distFemaleMales <- NetLogoR::NLdist(agents = turtle(turtles = sim$lynx, who = searchingFemID),
agents2 = turtle(turtles = sim$lynx, who = infoOtherFem[infoOtherMal < 3]),
torus = FALSE)
selectedMal <- ifelse(length(infoOtherFem[infoOtherMal < 3]) == 1,
infoOtherFem[infoOtherMal < 3],
# Select the closest male if there are several available
infoOtherFem[infoOtherMal < 3][which.min(distFemaleMales)])
# Associate the male to the female
sim$lynx <- NLset(turtles = sim$lynx, agents = turtle(turtles = sim$lynx, who = searchingFemID),
var = "maleID", val = selectedMal)
selectedMalInd <- turtle(turtles = sim$lynx, who = selectedMal)
sim$lynx <- NLset(turtles = sim$lynx, agents = selectedMalInd, var = "nFem",
val = selectedMalInd@.Data[, "nFem"] + 1)
}
}
} # end if(length(terrCells) == terrSize)
} # end if(searchingFemCellType == 4 & is.na(searchingFemCellAvail))
} # end for(searchingFemID in dispFemID)
sample.int(sim$habitatMap@maxPxcor, 1)
sim$habitatMap@maxPxcor
sim$habitatMap@maxPycor
